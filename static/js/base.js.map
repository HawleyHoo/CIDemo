{"version":3,"sources":["zepto.js","hammer.js","jquery.hammer.js"],"names":["global","factory","define","amd","this","window","Zepto","type","obj","String","class2type","toString","call","isFunction","value","isWindow","isDocument","nodeType","DOCUMENT_NODE","isObject","isPlainObject","Object","getPrototypeOf","prototype","likeArray","length","$","compact","array","filter","item","flatten","fn","concat","apply","dasherize","str","replace","toLowerCase","classRE","name","classCache","RegExp","maybeAddPx","cssNumber","defaultDisplay","nodeName","element","display","elementDisplay","document","createElement","body","appendChild","getComputedStyle","getPropertyValue","parentNode","removeChild","children","slice","map","childNodes","node","Z","dom","selector","i","len","extend","target","source","deep","key","isArray","undefined","filtered","nodes","funcArg","context","arg","idx","payload","setAttribute","removeAttribute","className","klass","svg","baseVal","deserializeValue","test","parseJSON","e","traverseNode","fun","classList","camelize","uniq","emptyArray","column-count","columns","font-weight","line-height","opacity","z-index","zoom","fragmentRE","singleTagRE","tagExpanderRE","rootNodeRE","capitalRE","methodAttributes","adjacencyOperators","table","tableRow","containers","tr","tbody","thead","tfoot","td","th","*","readyRE","simpleSelectorRE","zepto","tempParent","propMap","tabindex","readonly","for","class","maxlength","cellspacing","cellpadding","rowspan","colspan","usemap","frameborder","contenteditable","Array","object","matches","matchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","match","parent","temp","qsa","indexOf","chr","toUpperCase","fragment","html","properties","container","$1","innerHTML","each","attr","isZ","init","trim","find","ready","args","arguments","shift","forEach","found","maybeID","maybeClass","nameOnly","isSimple","getElementById","getElementsByClassName","getElementsByTagName","querySelectorAll","contains","documentElement","isEmptyObject","isNumeric","val","num","Number","isNaN","isFinite","inArray","elem","camelCase","uuid","support","expr","noop","elements","callback","values","push","grep","JSON","parse","split","constructor","reduce","sort","splice","toArray","el","readyState","addEventListener","get","size","remove","every","not","add","is","excludes","has","eq","first","last","$this","some","closest","collection","_","parents","ancestors","pluck","contents","contentDocument","siblings","child","empty","property","show","style","replaceWith","newContent","before","wrap","structure","func","clone","index","wrapAll","cloneNode","append","wrapInner","self","unwrap","hide","css","toggle","setting","prev","next","originHtml","text","newText","textContent","join","result","getAttribute","removeAttr","attribute","prop","removeProp","data","attrName","multiple","selected","offset","coordinates","coords","parentOffset","offsetParent","props","top","left","getBoundingClientRect","pageXOffset","pageYOffset","width","Math","round","height","computedStyle","removeProperty","cssText","hasClass","addClass","cls","removeClass","toggleClass","when","scrollTop","hasScrollTop","scrollTo","scrollX","scrollLeft","hasScrollLeft","scrollY","position","parseFloat","detach","dimension","dimensionProperty","m","operator","operatorIndex","inside","argType","arr","copyByClone","nextSibling","firstChild","parentInDocument","insertBefore","src","ownerDocument","defaultView","zid","_zid","findHandlers","event","ns","matcher","matcherFor","handlers","handler","sel","parts","eventCapture","captureSetting","del","focusinSupported","focus","realEvent","hover","events","delegator","capture","id","set","related","relatedTarget","proxy","compatible","isImmediatePropagationStopped","_args","preventDefault","stopPropagation","removeEventListener","isDefaultPrevented","eventMethods","predicate","sourceMethod","returnTrue","returnFalse","timeStamp","Date","now","defaultPrevented","returnValue","getPreventDefault","createProxy","originalEvent","ignoreProperties","isString","specialEvents","blur","mouseenter","mouseleave","click","mousedown","mouseup","mousemove","proxyFn","unshift","TypeError","bind","on","unbind","off","one","stopImmediatePropagation","delegate","undelegate","live","die","autoRemove","evt","currentTarget","liveFired","trigger","Event","dispatchEvent","triggerHandler","createEvent","bubbles","initEvent","triggerAndReturn","eventName","triggerGlobal","settings","ajaxStart","active","ajaxStop","ajaxBeforeSend","xhr","beforeSend","ajaxSuccess","deferred","success","resolveWith","ajaxComplete","ajaxError","error","rejectWith","status","complete","ajaxDataFilter","dataFilter","mimeToDataType","mime","htmlType","jsonType","scriptTypeRE","xmlTypeRE","appendQuery","url","query","serializeData","options","processData","param","traditional","dataType","parseArguments","serialize","params","scope","hash","jsonpID","rscript","blankRE","originAnchor","href","location","ajaxJSONP","ajax","responseData","abortTimeout","_callbackName","jsonpCallback","callbackName","script","originalCallback","abort","errorType","promise","clearTimeout","head","timeout","setTimeout","ajaxSettings","XMLHttpRequest","accepts","json","xml","crossDomain","cache","urlAnchor","hashIndex","Deferred","protocol","host","hasPlaceholder","jsonp","headers","setHeader","nativeSetHeader","setRequestHeader","mimeType","overrideMimeType","contentType","onreadystatechange","getResponseHeader","responseType","response","responseText","eval","responseXML","statusText","async","open","username","password","xhrFields","send","post","getJSON","load","escape","encodeURIComponent","serializeArray","field","disabled","checked","elm","submit","nativeGetComputedStyle","pseudoElement","exportName","setTimeoutContext","bindFn","invokeArrayArg","iterator","hasOwnProperty","deprecate","method","message","deprecationMessage","Error","stack","log","console","warn","inherit","base","childP","baseP","create","_super","assign","boolOrFn","TYPE_FUNCTION","ifUndefined","val1","val2","addEventListeners","types","splitStr","removeEventListeners","hasParent","inStr","findByKey","uniqueArray","results","a","b","prefixed","prefix","camelProp","VENDOR_PREFIXES","uniqueId","_uniqueId","getWindowForElement","doc","parentWindow","Input","manager","inputTarget","domHandler","ev","enable","createInputInstance","inputClass","SUPPORT_POINTER_EVENTS","PointerEventInput","SUPPORT_ONLY_TOUCH","TouchInput","SUPPORT_TOUCH","TouchMouseInput","MouseInput","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","INPUT_START","isFinal","INPUT_END","INPUT_CANCEL","session","computeInputData","emit","recognize","prevInput","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","deltaTime","angle","getAngle","distance","getDistance","computeDeltaXY","offsetDirection","getDirection","deltaX","deltaY","overallVelocity","getVelocity","overallVelocityX","x","overallVelocityY","y","abs","scale","getScale","rotation","getRotation","maxPointers","computeIntervalInputData","srcEvent","offsetDelta","prevDelta","velocity","velocityX","velocityY","direction","lastInterval","COMPUTE_INTERVAL","v","clientX","clientY","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","p1","p2","PROPS_XY","sqrt","atan2","PI","start","end","PROPS_CLIENT_XY","evEl","MOUSE_ELEMENT_EVENTS","evWin","MOUSE_WINDOW_EVENTS","pressed","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","store","pointerEvents","SingleTouchInput","evTarget","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","started","normalizeSingleTouches","all","touches","changed","changedTouches","TOUCH_TARGET_EVENTS","targetIds","getTouches","allTouches","INPUT_MOVE","identifier","targetTouches","changedTargetTouches","touch","mouse","primaryTouch","lastTouches","recordTouches","eventData","setLastTouch","lastTouch","lts","DEDUP_TIMEOUT","isSyntheticEvent","t","dx","dy","DEDUP_DISTANCE","TouchAction","cleanTouchActions","actions","TOUCH_ACTION_NONE","hasPanX","TOUCH_ACTION_PAN_X","hasPanY","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_AUTO","Recognizer","defaults","state","STATE_POSSIBLE","simultaneous","requireFail","stateStr","STATE_CANCELLED","STATE_ENDED","STATE_CHANGED","STATE_BEGAN","directionStr","getRecognizerByNameIfManager","otherRecognizer","recognizer","AttrRecognizer","PanRecognizer","pX","pY","PinchRecognizer","PressRecognizer","_timer","_input","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","Hammer","recognizers","preset","Manager","oldCssProps","touchAction","toggleCssProps","recognizeWith","requireFailure","cssProps","triggerDomEvent","gestureEvent","gesture","TEST_ELEMENT","output","nextKey","dest","merge","keys","MOBILE_REGEX","navigator","userAgent","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","destroy","MOUSE_INPUT_MAP","button","which","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","2","3","4","5","MSPointerEvent","PointerEvent","removePointer","eventTypeNormalized","isTouch","storeIndex","pointerId","SINGLE_TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TOUCH_INPUT_MAP","inputEvent","inputData","isMouse","sourceCapabilities","firesTouchEvents","PREFIXED_TOUCH_ACTION","NATIVE_TOUCH_ACTION","TOUCH_ACTION_MAP","touchMap","cssSupports","CSS","supports","compute","update","getTouchAction","preventDefaults","prevented","hasNone","isTapPointer","isTapMovement","isTapTouchTime","preventSrc","STATE_RECOGNIZED","dropRecognizeWith","dropRequireFailure","hasRequireFailures","canRecognizeWith","additionalEvent","tryEmit","canEmit","inputDataClone","reset","process","attrTest","optionPointers","isRecognized","isValid","threshold","directionTest","hasMoved","inOut","time","validPointers","validMovement","validTime","taps","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","VERSION","domEvents","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","stop","force","stopped","curRecognizer","existing","STATE_FAILED","Tap","Pan","Swipe","Pinch","Rotate","Press","module","exports","require","hammerify","$el","hammer","originalEmit"],"mappings":"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","file":"base.js","sourcesContent":["/* Zepto v1.2.0 - zepto event ajax form ie - zeptojs.com/license */\n(function(global, factory) {\n  if (typeof define === 'function' && define.amd)\n    define(function() { return factory(global) })\n  else\n    factory(global)\n}(this, function(window) {\n  var Zepto = (function() {\n  var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice,\n    document = window.document,\n    elementDisplay = {}, classCache = {},\n    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },\n    fragmentRE = /^\\s*<(\\w+|!)[^>]*>/,\n    singleTagRE = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n    tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,\n    rootNodeRE = /^(?:body|html)$/i,\n    capitalRE = /([A-Z])/g,\n\n    // special attributes that should be get/set via method calls\n    methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],\n\n    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],\n    table = document.createElement('table'),\n    tableRow = document.createElement('tr'),\n    containers = {\n      'tr': document.createElement('tbody'),\n      'tbody': table, 'thead': table, 'tfoot': table,\n      'td': tableRow, 'th': tableRow,\n      '*': document.createElement('div')\n    },\n    readyRE = /complete|loaded|interactive/,\n    simpleSelectorRE = /^[\\w-]*$/,\n    class2type = {},\n    toString = class2type.toString,\n    zepto = {},\n    camelize, uniq,\n    tempParent = document.createElement('div'),\n    propMap = {\n      'tabindex': 'tabIndex',\n      'readonly': 'readOnly',\n      'for': 'htmlFor',\n      'class': 'className',\n      'maxlength': 'maxLength',\n      'cellspacing': 'cellSpacing',\n      'cellpadding': 'cellPadding',\n      'rowspan': 'rowSpan',\n      'colspan': 'colSpan',\n      'usemap': 'useMap',\n      'frameborder': 'frameBorder',\n      'contenteditable': 'contentEditable'\n    },\n    isArray = Array.isArray ||\n      function(object){ return object instanceof Array }\n\n  zepto.matches = function(element, selector) {\n    if (!selector || !element || element.nodeType !== 1) return false\n    var matchesSelector = element.matches || element.webkitMatchesSelector ||\n                          element.mozMatchesSelector || element.oMatchesSelector ||\n                          element.matchesSelector\n    if (matchesSelector) return matchesSelector.call(element, selector)\n    // fall back to performing a selector:\n    var match, parent = element.parentNode, temp = !parent\n    if (temp) (parent = tempParent).appendChild(element)\n    match = ~zepto.qsa(parent, selector).indexOf(element)\n    temp && tempParent.removeChild(element)\n    return match\n  }\n\n  function type(obj) {\n    return obj == null ? String(obj) :\n      class2type[toString.call(obj)] || \"object\"\n  }\n\n  function isFunction(value) { return type(value) == \"function\" }\n  function isWindow(obj)     { return obj != null && obj == obj.window }\n  function isDocument(obj)   { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }\n  function isObject(obj)     { return type(obj) == \"object\" }\n  function isPlainObject(obj) {\n    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype\n  }\n\n  function likeArray(obj) {\n    var length = !!obj && 'length' in obj && obj.length,\n      type = $.type(obj)\n\n    return 'function' != type && !isWindow(obj) && (\n      'array' == type || length === 0 ||\n        (typeof length == 'number' && length > 0 && (length - 1) in obj)\n    )\n  }\n\n  function compact(array) { return filter.call(array, function(item){ return item != null }) }\n  function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array }\n  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }\n  function dasherize(str) {\n    return str.replace(/::/g, '/')\n           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\n           .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n           .replace(/_/g, '-')\n           .toLowerCase()\n  }\n  uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) }\n\n  function classRE(name) {\n    return name in classCache ?\n      classCache[name] : (classCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)'))\n  }\n\n  function maybeAddPx(name, value) {\n    return (typeof value == \"number\" && !cssNumber[dasherize(name)]) ? value + \"px\" : value\n  }\n\n  function defaultDisplay(nodeName) {\n    var element, display\n    if (!elementDisplay[nodeName]) {\n      element = document.createElement(nodeName)\n      document.body.appendChild(element)\n      display = getComputedStyle(element, '').getPropertyValue(\"display\")\n      element.parentNode.removeChild(element)\n      display == \"none\" && (display = \"block\")\n      elementDisplay[nodeName] = display\n    }\n    return elementDisplay[nodeName]\n  }\n\n  function children(element) {\n    return 'children' in element ?\n      slice.call(element.children) :\n      $.map(element.childNodes, function(node){ if (node.nodeType == 1) return node })\n  }\n\n  function Z(dom, selector) {\n    var i, len = dom ? dom.length : 0\n    for (i = 0; i < len; i++) this[i] = dom[i]\n    this.length = len\n    this.selector = selector || ''\n  }\n\n  // `$.zepto.fragment` takes a html string and an optional tag name\n  // to generate DOM nodes from the given html string.\n  // The generated DOM nodes are returned as an array.\n  // This function can be overridden in plugins for example to make\n  // it compatible with browsers that don't support the DOM fully.\n  zepto.fragment = function(html, name, properties) {\n    var dom, nodes, container\n\n    // A special case optimization for a single tag\n    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1))\n\n    if (!dom) {\n      if (html.replace) html = html.replace(tagExpanderRE, \"<$1></$2>\")\n      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1\n      if (!(name in containers)) name = '*'\n\n      container = containers[name]\n      container.innerHTML = '' + html\n      dom = $.each(slice.call(container.childNodes), function(){\n        container.removeChild(this)\n      })\n    }\n\n    if (isPlainObject(properties)) {\n      nodes = $(dom)\n      $.each(properties, function(key, value) {\n        if (methodAttributes.indexOf(key) > -1) nodes[key](value)\n        else nodes.attr(key, value)\n      })\n    }\n\n    return dom\n  }\n\n  // `$.zepto.Z` swaps out the prototype of the given `dom` array\n  // of nodes with `$.fn` and thus supplying all the Zepto functions\n  // to the array. This method can be overridden in plugins.\n  zepto.Z = function(dom, selector) {\n    return new Z(dom, selector)\n  }\n\n  // `$.zepto.isZ` should return `true` if the given object is a Zepto\n  // collection. This method can be overridden in plugins.\n  zepto.isZ = function(object) {\n    return object instanceof zepto.Z\n  }\n\n  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and\n  // takes a CSS selector and an optional context (and handles various\n  // special cases).\n  // This method can be overridden in plugins.\n  zepto.init = function(selector, context) {\n    var dom\n    // If nothing given, return an empty Zepto collection\n    if (!selector) return zepto.Z()\n    // Optimize for string selectors\n    else if (typeof selector == 'string') {\n      selector = selector.trim()\n      // If it's a html fragment, create nodes from it\n      // Note: In both Chrome 21 and Firefox 15, DOM error 12\n      // is thrown if the fragment doesn't begin with <\n      if (selector[0] == '<' && fragmentRE.test(selector))\n        dom = zepto.fragment(selector, RegExp.$1, context), selector = null\n      // If there's a context, create a collection on that context first, and select\n      // nodes from there\n      else if (context !== undefined) return $(context).find(selector)\n      // If it's a CSS selector, use it to select nodes.\n      else dom = zepto.qsa(document, selector)\n    }\n    // If a function is given, call it when the DOM is ready\n    else if (isFunction(selector)) return $(document).ready(selector)\n    // If a Zepto collection is given, just return it\n    else if (zepto.isZ(selector)) return selector\n    else {\n      // normalize array if an array of nodes is given\n      if (isArray(selector)) dom = compact(selector)\n      // Wrap DOM nodes.\n      else if (isObject(selector))\n        dom = [selector], selector = null\n      // If it's a html fragment, create nodes from it\n      else if (fragmentRE.test(selector))\n        dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null\n      // If there's a context, create a collection on that context first, and select\n      // nodes from there\n      else if (context !== undefined) return $(context).find(selector)\n      // And last but no least, if it's a CSS selector, use it to select nodes.\n      else dom = zepto.qsa(document, selector)\n    }\n    // create a new Zepto collection from the nodes found\n    return zepto.Z(dom, selector)\n  }\n\n  // `$` will be the base `Zepto` object. When calling this\n  // function just call `$.zepto.init, which makes the implementation\n  // details of selecting nodes and creating Zepto collections\n  // patchable in plugins.\n  $ = function(selector, context){\n    return zepto.init(selector, context)\n  }\n\n  function extend(target, source, deep) {\n    for (key in source)\n      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\n        if (isPlainObject(source[key]) && !isPlainObject(target[key]))\n          target[key] = {}\n        if (isArray(source[key]) && !isArray(target[key]))\n          target[key] = []\n        extend(target[key], source[key], deep)\n      }\n      else if (source[key] !== undefined) target[key] = source[key]\n  }\n\n  // Copy all but undefined properties from one or more\n  // objects to the `target` object.\n  $.extend = function(target){\n    var deep, args = slice.call(arguments, 1)\n    if (typeof target == 'boolean') {\n      deep = target\n      target = args.shift()\n    }\n    args.forEach(function(arg){ extend(target, arg, deep) })\n    return target\n  }\n\n  // `$.zepto.qsa` is Zepto's CSS selector implementation which\n  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.\n  // This method can be overridden in plugins.\n  zepto.qsa = function(element, selector){\n    var found,\n        maybeID = selector[0] == '#',\n        maybeClass = !maybeID && selector[0] == '.',\n        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked\n        isSimple = simpleSelectorRE.test(nameOnly)\n    return (element.getElementById && isSimple && maybeID) ? // Safari DocumentFragment doesn't have getElementById\n      ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :\n      (element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11) ? [] :\n      slice.call(\n        isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName\n          maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class\n          element.getElementsByTagName(selector) : // Or a tag\n          element.querySelectorAll(selector) // Or it's not simple, and we need to query all\n      )\n  }\n\n  function filtered(nodes, selector) {\n    return selector == null ? $(nodes) : $(nodes).filter(selector)\n  }\n\n  $.contains = document.documentElement.contains ?\n    function(parent, node) {\n      return parent !== node && parent.contains(node)\n    } :\n    function(parent, node) {\n      while (node && (node = node.parentNode))\n        if (node === parent) return true\n      return false\n    }\n\n  function funcArg(context, arg, idx, payload) {\n    return isFunction(arg) ? arg.call(context, idx, payload) : arg\n  }\n\n  function setAttribute(node, name, value) {\n    value == null ? node.removeAttribute(name) : node.setAttribute(name, value)\n  }\n\n  // access className property while respecting SVGAnimatedString\n  function className(node, value){\n    var klass = node.className || '',\n        svg   = klass && klass.baseVal !== undefined\n\n    if (value === undefined) return svg ? klass.baseVal : klass\n    svg ? (klass.baseVal = value) : (node.className = value)\n  }\n\n  // \"true\"  => true\n  // \"false\" => false\n  // \"null\"  => null\n  // \"42\"    => 42\n  // \"42.5\"  => 42.5\n  // \"08\"    => \"08\"\n  // JSON    => parse if valid\n  // String  => self\n  function deserializeValue(value) {\n    try {\n      return value ?\n        value == \"true\" ||\n        ( value == \"false\" ? false :\n          value == \"null\" ? null :\n          +value + \"\" == value ? +value :\n          /^[\\[\\{]/.test(value) ? $.parseJSON(value) :\n          value )\n        : value\n    } catch(e) {\n      return value\n    }\n  }\n\n  $.type = type\n  $.isFunction = isFunction\n  $.isWindow = isWindow\n  $.isArray = isArray\n  $.isPlainObject = isPlainObject\n\n  $.isEmptyObject = function(obj) {\n    var name\n    for (name in obj) return false\n    return true\n  }\n\n  $.isNumeric = function(val) {\n    var num = Number(val), type = typeof val\n    return val != null && type != 'boolean' &&\n      (type != 'string' || val.length) &&\n      !isNaN(num) && isFinite(num) || false\n  }\n\n  $.inArray = function(elem, array, i){\n    return emptyArray.indexOf.call(array, elem, i)\n  }\n\n  $.camelCase = camelize\n  $.trim = function(str) {\n    return str == null ? \"\" : String.prototype.trim.call(str)\n  }\n\n  // plugin compatibility\n  $.uuid = 0\n  $.support = { }\n  $.expr = { }\n  $.noop = function() {}\n\n  $.map = function(elements, callback){\n    var value, values = [], i, key\n    if (likeArray(elements))\n      for (i = 0; i < elements.length; i++) {\n        value = callback(elements[i], i)\n        if (value != null) values.push(value)\n      }\n    else\n      for (key in elements) {\n        value = callback(elements[key], key)\n        if (value != null) values.push(value)\n      }\n    return flatten(values)\n  }\n\n  $.each = function(elements, callback){\n    var i, key\n    if (likeArray(elements)) {\n      for (i = 0; i < elements.length; i++)\n        if (callback.call(elements[i], i, elements[i]) === false) return elements\n    } else {\n      for (key in elements)\n        if (callback.call(elements[key], key, elements[key]) === false) return elements\n    }\n\n    return elements\n  }\n\n  $.grep = function(elements, callback){\n    return filter.call(elements, callback)\n  }\n\n  if (window.JSON) $.parseJSON = JSON.parse\n\n  // Populate the class2type map\n  $.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n    class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase()\n  })\n\n  // Define methods that will be available on all\n  // Zepto collections\n  $.fn = {\n    constructor: zepto.Z,\n    length: 0,\n\n    // Because a collection acts like an array\n    // copy over these useful array functions.\n    forEach: emptyArray.forEach,\n    reduce: emptyArray.reduce,\n    push: emptyArray.push,\n    sort: emptyArray.sort,\n    splice: emptyArray.splice,\n    indexOf: emptyArray.indexOf,\n    concat: function(){\n      var i, value, args = []\n      for (i = 0; i < arguments.length; i++) {\n        value = arguments[i]\n        args[i] = zepto.isZ(value) ? value.toArray() : value\n      }\n      return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)\n    },\n\n    // `map` and `slice` in the jQuery API work differently\n    // from their array counterparts\n    map: function(fn){\n      return $($.map(this, function(el, i){ return fn.call(el, i, el) }))\n    },\n    slice: function(){\n      return $(slice.apply(this, arguments))\n    },\n\n    ready: function(callback){\n      // need to check if document.body exists for IE as that browser reports\n      // document ready when it hasn't yet created the body element\n      if (readyRE.test(document.readyState) && document.body) callback($)\n      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)\n      return this\n    },\n    get: function(idx){\n      return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]\n    },\n    toArray: function(){ return this.get() },\n    size: function(){\n      return this.length\n    },\n    remove: function(){\n      return this.each(function(){\n        if (this.parentNode != null)\n          this.parentNode.removeChild(this)\n      })\n    },\n    each: function(callback){\n      emptyArray.every.call(this, function(el, idx){\n        return callback.call(el, idx, el) !== false\n      })\n      return this\n    },\n    filter: function(selector){\n      if (isFunction(selector)) return this.not(this.not(selector))\n      return $(filter.call(this, function(element){\n        return zepto.matches(element, selector)\n      }))\n    },\n    add: function(selector,context){\n      return $(uniq(this.concat($(selector,context))))\n    },\n    is: function(selector){\n      return this.length > 0 && zepto.matches(this[0], selector)\n    },\n    not: function(selector){\n      var nodes=[]\n      if (isFunction(selector) && selector.call !== undefined)\n        this.each(function(idx){\n          if (!selector.call(this,idx)) nodes.push(this)\n        })\n      else {\n        var excludes = typeof selector == 'string' ? this.filter(selector) :\n          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)\n        this.forEach(function(el){\n          if (excludes.indexOf(el) < 0) nodes.push(el)\n        })\n      }\n      return $(nodes)\n    },\n    has: function(selector){\n      return this.filter(function(){\n        return isObject(selector) ?\n          $.contains(this, selector) :\n          $(this).find(selector).size()\n      })\n    },\n    eq: function(idx){\n      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)\n    },\n    first: function(){\n      var el = this[0]\n      return el && !isObject(el) ? el : $(el)\n    },\n    last: function(){\n      var el = this[this.length - 1]\n      return el && !isObject(el) ? el : $(el)\n    },\n    find: function(selector){\n      var result, $this = this\n      if (!selector) result = $()\n      else if (typeof selector == 'object')\n        result = $(selector).filter(function(){\n          var node = this\n          return emptyArray.some.call($this, function(parent){\n            return $.contains(parent, node)\n          })\n        })\n      else if (this.length == 1) result = $(zepto.qsa(this[0], selector))\n      else result = this.map(function(){ return zepto.qsa(this, selector) })\n      return result\n    },\n    closest: function(selector, context){\n      var nodes = [], collection = typeof selector == 'object' && $(selector)\n      this.each(function(_, node){\n        while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector)))\n          node = node !== context && !isDocument(node) && node.parentNode\n        if (node && nodes.indexOf(node) < 0) nodes.push(node)\n      })\n      return $(nodes)\n    },\n    parents: function(selector){\n      var ancestors = [], nodes = this\n      while (nodes.length > 0)\n        nodes = $.map(nodes, function(node){\n          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {\n            ancestors.push(node)\n            return node\n          }\n        })\n      return filtered(ancestors, selector)\n    },\n    parent: function(selector){\n      return filtered(uniq(this.pluck('parentNode')), selector)\n    },\n    children: function(selector){\n      return filtered(this.map(function(){ return children(this) }), selector)\n    },\n    contents: function() {\n      return this.map(function() { return this.contentDocument || slice.call(this.childNodes) })\n    },\n    siblings: function(selector){\n      return filtered(this.map(function(i, el){\n        return filter.call(children(el.parentNode), function(child){ return child!==el })\n      }), selector)\n    },\n    empty: function(){\n      return this.each(function(){ this.innerHTML = '' })\n    },\n    // `pluck` is borrowed from Prototype.js\n    pluck: function(property){\n      return $.map(this, function(el){ return el[property] })\n    },\n    show: function(){\n      return this.each(function(){\n        this.style.display == \"none\" && (this.style.display = '')\n        if (getComputedStyle(this, '').getPropertyValue(\"display\") == \"none\")\n          this.style.display = defaultDisplay(this.nodeName)\n      })\n    },\n    replaceWith: function(newContent){\n      return this.before(newContent).remove()\n    },\n    wrap: function(structure){\n      var func = isFunction(structure)\n      if (this[0] && !func)\n        var dom   = $(structure).get(0),\n            clone = dom.parentNode || this.length > 1\n\n      return this.each(function(index){\n        $(this).wrapAll(\n          func ? structure.call(this, index) :\n            clone ? dom.cloneNode(true) : dom\n        )\n      })\n    },\n    wrapAll: function(structure){\n      if (this[0]) {\n        $(this[0]).before(structure = $(structure))\n        var children\n        // drill down to the inmost element\n        while ((children = structure.children()).length) structure = children.first()\n        $(structure).append(this)\n      }\n      return this\n    },\n    wrapInner: function(structure){\n      var func = isFunction(structure)\n      return this.each(function(index){\n        var self = $(this), contents = self.contents(),\n            dom  = func ? structure.call(this, index) : structure\n        contents.length ? contents.wrapAll(dom) : self.append(dom)\n      })\n    },\n    unwrap: function(){\n      this.parent().each(function(){\n        $(this).replaceWith($(this).children())\n      })\n      return this\n    },\n    clone: function(){\n      return this.map(function(){ return this.cloneNode(true) })\n    },\n    hide: function(){\n      return this.css(\"display\", \"none\")\n    },\n    toggle: function(setting){\n      return this.each(function(){\n        var el = $(this)\n        ;(setting === undefined ? el.css(\"display\") == \"none\" : setting) ? el.show() : el.hide()\n      })\n    },\n    prev: function(selector){ return $(this.pluck('previousElementSibling')).filter(selector || '*') },\n    next: function(selector){ return $(this.pluck('nextElementSibling')).filter(selector || '*') },\n    html: function(html){\n      return 0 in arguments ?\n        this.each(function(idx){\n          var originHtml = this.innerHTML\n          $(this).empty().append( funcArg(this, html, idx, originHtml) )\n        }) :\n        (0 in this ? this[0].innerHTML : null)\n    },\n    text: function(text){\n      return 0 in arguments ?\n        this.each(function(idx){\n          var newText = funcArg(this, text, idx, this.textContent)\n          this.textContent = newText == null ? '' : ''+newText\n        }) :\n        (0 in this ? this.pluck('textContent').join(\"\") : null)\n    },\n    attr: function(name, value){\n      var result\n      return (typeof name == 'string' && !(1 in arguments)) ?\n        (0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined) :\n        this.each(function(idx){\n          if (this.nodeType !== 1) return\n          if (isObject(name)) for (key in name) setAttribute(this, key, name[key])\n          else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)))\n        })\n    },\n    removeAttr: function(name){\n      return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){\n        setAttribute(this, attribute)\n      }, this)})\n    },\n    prop: function(name, value){\n      name = propMap[name] || name\n      return (1 in arguments) ?\n        this.each(function(idx){\n          this[name] = funcArg(this, value, idx, this[name])\n        }) :\n        (this[0] && this[0][name])\n    },\n    removeProp: function(name){\n      name = propMap[name] || name\n      return this.each(function(){ delete this[name] })\n    },\n    data: function(name, value){\n      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase()\n\n      var data = (1 in arguments) ?\n        this.attr(attrName, value) :\n        this.attr(attrName)\n\n      return data !== null ? deserializeValue(data) : undefined\n    },\n    val: function(value){\n      if (0 in arguments) {\n        if (value == null) value = \"\"\n        return this.each(function(idx){\n          this.value = funcArg(this, value, idx, this.value)\n        })\n      } else {\n        return this[0] && (this[0].multiple ?\n           $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value') :\n           this[0].value)\n      }\n    },\n    offset: function(coordinates){\n      if (coordinates) return this.each(function(index){\n        var $this = $(this),\n            coords = funcArg(this, coordinates, index, $this.offset()),\n            parentOffset = $this.offsetParent().offset(),\n            props = {\n              top:  coords.top  - parentOffset.top,\n              left: coords.left - parentOffset.left\n            }\n\n        if ($this.css('position') == 'static') props['position'] = 'relative'\n        $this.css(props)\n      })\n      if (!this.length) return null\n      if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0]))\n        return {top: 0, left: 0}\n      var obj = this[0].getBoundingClientRect()\n      return {\n        left: obj.left + window.pageXOffset,\n        top: obj.top + window.pageYOffset,\n        width: Math.round(obj.width),\n        height: Math.round(obj.height)\n      }\n    },\n    css: function(property, value){\n      if (arguments.length < 2) {\n        var element = this[0]\n        if (typeof property == 'string') {\n          if (!element) return\n          return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property)\n        } else if (isArray(property)) {\n          if (!element) return\n          var props = {}\n          var computedStyle = getComputedStyle(element, '')\n          $.each(property, function(_, prop){\n            props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop))\n          })\n          return props\n        }\n      }\n\n      var css = ''\n      if (type(property) == 'string') {\n        if (!value && value !== 0)\n          this.each(function(){ this.style.removeProperty(dasherize(property)) })\n        else\n          css = dasherize(property) + \":\" + maybeAddPx(property, value)\n      } else {\n        for (key in property)\n          if (!property[key] && property[key] !== 0)\n            this.each(function(){ this.style.removeProperty(dasherize(key)) })\n          else\n            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'\n      }\n\n      return this.each(function(){ this.style.cssText += ';' + css })\n    },\n    index: function(element){\n      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])\n    },\n    hasClass: function(name){\n      if (!name) return false\n      return emptyArray.some.call(this, function(el){\n        return this.test(className(el))\n      }, classRE(name))\n    },\n    addClass: function(name){\n      if (!name) return this\n      return this.each(function(idx){\n        if (!('className' in this)) return\n        classList = []\n        var cls = className(this), newName = funcArg(this, name, idx, cls)\n        newName.split(/\\s+/g).forEach(function(klass){\n          if (!$(this).hasClass(klass)) classList.push(klass)\n        }, this)\n        classList.length && className(this, cls + (cls ? \" \" : \"\") + classList.join(\" \"))\n      })\n    },\n    removeClass: function(name){\n      return this.each(function(idx){\n        if (!('className' in this)) return\n        if (name === undefined) return className(this, '')\n        classList = className(this)\n        funcArg(this, name, idx, classList).split(/\\s+/g).forEach(function(klass){\n          classList = classList.replace(classRE(klass), \" \")\n        })\n        className(this, classList.trim())\n      })\n    },\n    toggleClass: function(name, when){\n      if (!name) return this\n      return this.each(function(idx){\n        var $this = $(this), names = funcArg(this, name, idx, className(this))\n        names.split(/\\s+/g).forEach(function(klass){\n          (when === undefined ? !$this.hasClass(klass) : when) ?\n            $this.addClass(klass) : $this.removeClass(klass)\n        })\n      })\n    },\n    scrollTop: function(value){\n      if (!this.length) return\n      var hasScrollTop = 'scrollTop' in this[0]\n      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset\n      return this.each(hasScrollTop ?\n        function(){ this.scrollTop = value } :\n        function(){ this.scrollTo(this.scrollX, value) })\n    },\n    scrollLeft: function(value){\n      if (!this.length) return\n      var hasScrollLeft = 'scrollLeft' in this[0]\n      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset\n      return this.each(hasScrollLeft ?\n        function(){ this.scrollLeft = value } :\n        function(){ this.scrollTo(value, this.scrollY) })\n    },\n    position: function() {\n      if (!this.length) return\n\n      var elem = this[0],\n        // Get *real* offsetParent\n        offsetParent = this.offsetParent(),\n        // Get correct offsets\n        offset       = this.offset(),\n        parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset()\n\n      // Subtract element margins\n      // note: when an element has margin: auto the offsetLeft and marginLeft\n      // are the same in Safari causing offset.left to incorrectly be 0\n      offset.top  -= parseFloat( $(elem).css('margin-top') ) || 0\n      offset.left -= parseFloat( $(elem).css('margin-left') ) || 0\n\n      // Add offsetParent borders\n      parentOffset.top  += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0\n      parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0\n\n      // Subtract the two offsets\n      return {\n        top:  offset.top  - parentOffset.top,\n        left: offset.left - parentOffset.left\n      }\n    },\n    offsetParent: function() {\n      return this.map(function(){\n        var parent = this.offsetParent || document.body\n        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css(\"position\") == \"static\")\n          parent = parent.offsetParent\n        return parent\n      })\n    }\n  }\n\n  // for now\n  $.fn.detach = $.fn.remove\n\n  // Generate the `width` and `height` functions\n  ;['width', 'height'].forEach(function(dimension){\n    var dimensionProperty =\n      dimension.replace(/./, function(m){ return m[0].toUpperCase() })\n\n    $.fn[dimension] = function(value){\n      var offset, el = this[0]\n      if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] :\n        isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :\n        (offset = this.offset()) && offset[dimension]\n      else return this.each(function(idx){\n        el = $(this)\n        el.css(dimension, funcArg(this, value, idx, el[dimension]()))\n      })\n    }\n  })\n\n  function traverseNode(node, fun) {\n    fun(node)\n    for (var i = 0, len = node.childNodes.length; i < len; i++)\n      traverseNode(node.childNodes[i], fun)\n  }\n\n  // Generate the `after`, `prepend`, `before`, `append`,\n  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.\n  adjacencyOperators.forEach(function(operator, operatorIndex) {\n    var inside = operatorIndex % 2 //=> prepend, append\n\n    $.fn[operator] = function(){\n      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings\n      var argType, nodes = $.map(arguments, function(arg) {\n            var arr = []\n            argType = type(arg)\n            if (argType == \"array\") {\n              arg.forEach(function(el) {\n                if (el.nodeType !== undefined) return arr.push(el)\n                else if ($.zepto.isZ(el)) return arr = arr.concat(el.get())\n                arr = arr.concat(zepto.fragment(el))\n              })\n              return arr\n            }\n            return argType == \"object\" || arg == null ?\n              arg : zepto.fragment(arg)\n          }),\n          parent, copyByClone = this.length > 1\n      if (nodes.length < 1) return this\n\n      return this.each(function(_, target){\n        parent = inside ? target : target.parentNode\n\n        // convert all methods to a \"before\" operation\n        target = operatorIndex == 0 ? target.nextSibling :\n                 operatorIndex == 1 ? target.firstChild :\n                 operatorIndex == 2 ? target :\n                 null\n\n        var parentInDocument = $.contains(document.documentElement, parent)\n\n        nodes.forEach(function(node){\n          if (copyByClone) node = node.cloneNode(true)\n          else if (!parent) return $(node).remove()\n\n          parent.insertBefore(node, target)\n          if (parentInDocument) traverseNode(node, function(el){\n            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&\n               (!el.type || el.type === 'text/javascript') && !el.src){\n              var target = el.ownerDocument ? el.ownerDocument.defaultView : window\n              target['eval'].call(target, el.innerHTML)\n            }\n          })\n        })\n      })\n    }\n\n    // after    => insertAfter\n    // prepend  => prependTo\n    // before   => insertBefore\n    // append   => appendTo\n    $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html){\n      $(html)[operator](this)\n      return this\n    }\n  })\n\n  zepto.Z.prototype = Z.prototype = $.fn\n\n  // Export internal API functions in the `$.zepto` namespace\n  zepto.uniq = uniq\n  zepto.deserializeValue = deserializeValue\n  $.zepto = zepto\n\n  return $\n})()\n\nwindow.Zepto = Zepto\nwindow.$ === undefined && (window.$ = Zepto)\n\n;(function($){\n  var _zid = 1, undefined,\n      slice = Array.prototype.slice,\n      isFunction = $.isFunction,\n      isString = function(obj){ return typeof obj == 'string' },\n      handlers = {},\n      specialEvents={},\n      focusinSupported = 'onfocusin' in window,\n      focus = { focus: 'focusin', blur: 'focusout' },\n      hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' }\n\n  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'\n\n  function zid(element) {\n    return element._zid || (element._zid = _zid++)\n  }\n  function findHandlers(element, event, fn, selector) {\n    event = parse(event)\n    if (event.ns) var matcher = matcherFor(event.ns)\n    return (handlers[zid(element)] || []).filter(function(handler) {\n      return handler\n        && (!event.e  || handler.e == event.e)\n        && (!event.ns || matcher.test(handler.ns))\n        && (!fn       || zid(handler.fn) === zid(fn))\n        && (!selector || handler.sel == selector)\n    })\n  }\n  function parse(event) {\n    var parts = ('' + event).split('.')\n    return {e: parts[0], ns: parts.slice(1).sort().join(' ')}\n  }\n  function matcherFor(ns) {\n    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')\n  }\n\n  function eventCapture(handler, captureSetting) {\n    return handler.del &&\n      (!focusinSupported && (handler.e in focus)) ||\n      !!captureSetting\n  }\n\n  function realEvent(type) {\n    return hover[type] || (focusinSupported && focus[type]) || type\n  }\n\n  function add(element, events, fn, data, selector, delegator, capture){\n    var id = zid(element), set = (handlers[id] || (handlers[id] = []))\n    events.split(/\\s/).forEach(function(event){\n      if (event == 'ready') return $(document).ready(fn)\n      var handler   = parse(event)\n      handler.fn    = fn\n      handler.sel   = selector\n      // emulate mouseenter, mouseleave\n      if (handler.e in hover) fn = function(e){\n        var related = e.relatedTarget\n        if (!related || (related !== this && !$.contains(this, related)))\n          return handler.fn.apply(this, arguments)\n      }\n      handler.del   = delegator\n      var callback  = delegator || fn\n      handler.proxy = function(e){\n        e = compatible(e)\n        if (e.isImmediatePropagationStopped()) return\n        e.data = data\n        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args))\n        if (result === false) e.preventDefault(), e.stopPropagation()\n        return result\n      }\n      handler.i = set.length\n      set.push(handler)\n      if ('addEventListener' in element)\n        element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\n    })\n  }\n  function remove(element, events, fn, selector, capture){\n    var id = zid(element)\n    ;(events || '').split(/\\s/).forEach(function(event){\n      findHandlers(element, event, fn, selector).forEach(function(handler){\n        delete handlers[id][handler.i]\n      if ('removeEventListener' in element)\n        element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\n      })\n    })\n  }\n\n  $.event = { add: add, remove: remove }\n\n  $.proxy = function(fn, context) {\n    var args = (2 in arguments) && slice.call(arguments, 2)\n    if (isFunction(fn)) {\n      var proxyFn = function(){ return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) }\n      proxyFn._zid = zid(fn)\n      return proxyFn\n    } else if (isString(context)) {\n      if (args) {\n        args.unshift(fn[context], fn)\n        return $.proxy.apply(null, args)\n      } else {\n        return $.proxy(fn[context], fn)\n      }\n    } else {\n      throw new TypeError(\"expected function\")\n    }\n  }\n\n  $.fn.bind = function(event, data, callback){\n    return this.on(event, data, callback)\n  }\n  $.fn.unbind = function(event, callback){\n    return this.off(event, callback)\n  }\n  $.fn.one = function(event, selector, data, callback){\n    return this.on(event, selector, data, callback, 1)\n  }\n\n  var returnTrue = function(){return true},\n      returnFalse = function(){return false},\n      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,\n      eventMethods = {\n        preventDefault: 'isDefaultPrevented',\n        stopImmediatePropagation: 'isImmediatePropagationStopped',\n        stopPropagation: 'isPropagationStopped'\n      }\n\n  function compatible(event, source) {\n    if (source || !event.isDefaultPrevented) {\n      source || (source = event)\n\n      $.each(eventMethods, function(name, predicate) {\n        var sourceMethod = source[name]\n        event[name] = function(){\n          this[predicate] = returnTrue\n          return sourceMethod && sourceMethod.apply(source, arguments)\n        }\n        event[predicate] = returnFalse\n      })\n\n      event.timeStamp || (event.timeStamp = Date.now())\n\n      if (source.defaultPrevented !== undefined ? source.defaultPrevented :\n          'returnValue' in source ? source.returnValue === false :\n          source.getPreventDefault && source.getPreventDefault())\n        event.isDefaultPrevented = returnTrue\n    }\n    return event\n  }\n\n  function createProxy(event) {\n    var key, proxy = { originalEvent: event }\n    for (key in event)\n      if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key]\n\n    return compatible(proxy, event)\n  }\n\n  $.fn.delegate = function(selector, event, callback){\n    return this.on(event, selector, callback)\n  }\n  $.fn.undelegate = function(selector, event, callback){\n    return this.off(event, selector, callback)\n  }\n\n  $.fn.live = function(event, callback){\n    $(document.body).delegate(this.selector, event, callback)\n    return this\n  }\n  $.fn.die = function(event, callback){\n    $(document.body).undelegate(this.selector, event, callback)\n    return this\n  }\n\n  $.fn.on = function(event, selector, data, callback, one){\n    var autoRemove, delegator, $this = this\n    if (event && !isString(event)) {\n      $.each(event, function(type, fn){\n        $this.on(type, selector, data, fn, one)\n      })\n      return $this\n    }\n\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\n      callback = data, data = selector, selector = undefined\n    if (callback === undefined || data === false)\n      callback = data, data = undefined\n\n    if (callback === false) callback = returnFalse\n\n    return $this.each(function(_, element){\n      if (one) autoRemove = function(e){\n        remove(element, e.type, callback)\n        return callback.apply(this, arguments)\n      }\n\n      if (selector) delegator = function(e){\n        var evt, match = $(e.target).closest(selector, element).get(0)\n        if (match && match !== element) {\n          evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})\n          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))\n        }\n      }\n\n      add(element, event, callback, data, selector, delegator || autoRemove)\n    })\n  }\n  $.fn.off = function(event, selector, callback){\n    var $this = this\n    if (event && !isString(event)) {\n      $.each(event, function(type, fn){\n        $this.off(type, selector, fn)\n      })\n      return $this\n    }\n\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\n      callback = selector, selector = undefined\n\n    if (callback === false) callback = returnFalse\n\n    return $this.each(function(){\n      remove(this, event, callback, selector)\n    })\n  }\n\n  $.fn.trigger = function(event, args){\n    event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)\n    event._args = args\n    return this.each(function(){\n      // handle focus(), blur() by calling them directly\n      if (event.type in focus && typeof this[event.type] == \"function\") this[event.type]()\n      // items in the collection might not be DOM elements\n      else if ('dispatchEvent' in this) this.dispatchEvent(event)\n      else $(this).triggerHandler(event, args)\n    })\n  }\n\n  // triggers event handlers on current element just as if an event occurred,\n  // doesn't trigger an actual event, doesn't bubble\n  $.fn.triggerHandler = function(event, args){\n    var e, result\n    this.each(function(i, element){\n      e = createProxy(isString(event) ? $.Event(event) : event)\n      e._args = args\n      e.target = element\n      $.each(findHandlers(element, event.type || event), function(i, handler){\n        result = handler.proxy(e)\n        if (e.isImmediatePropagationStopped()) return false\n      })\n    })\n    return result\n  }\n\n  // shortcut methods for `.bind(event, fn)` for each event type\n  ;('focusin focusout focus blur load resize scroll unload click dblclick '+\n  'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+\n  'change select keydown keypress keyup error').split(' ').forEach(function(event) {\n    $.fn[event] = function(callback) {\n      return (0 in arguments) ?\n        this.bind(event, callback) :\n        this.trigger(event)\n    }\n  })\n\n  $.Event = function(type, props) {\n    if (!isString(type)) props = type, type = props.type\n    var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true\n    if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])\n    event.initEvent(type, bubbles, true)\n    return compatible(event)\n  }\n\n})(Zepto)\n\n;(function($){\n  var jsonpID = +new Date(),\n      document = window.document,\n      key,\n      name,\n      rscript = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n      scriptTypeRE = /^(?:text|application)\\/javascript/i,\n      xmlTypeRE = /^(?:text|application)\\/xml/i,\n      jsonType = 'application/json',\n      htmlType = 'text/html',\n      blankRE = /^\\s*$/,\n      originAnchor = document.createElement('a')\n\n  originAnchor.href = window.location.href\n\n  // trigger a custom event and return false if it was cancelled\n  function triggerAndReturn(context, eventName, data) {\n    var event = $.Event(eventName)\n    $(context).trigger(event, data)\n    return !event.isDefaultPrevented()\n  }\n\n  // trigger an Ajax \"global\" event\n  function triggerGlobal(settings, context, eventName, data) {\n    if (settings.global) return triggerAndReturn(context || document, eventName, data)\n  }\n\n  // Number of active Ajax requests\n  $.active = 0\n\n  function ajaxStart(settings) {\n    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')\n  }\n  function ajaxStop(settings) {\n    if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')\n  }\n\n  // triggers an extra global event \"ajaxBeforeSend\" that's like \"ajaxSend\" but cancelable\n  function ajaxBeforeSend(xhr, settings) {\n    var context = settings.context\n    if (settings.beforeSend.call(context, xhr, settings) === false ||\n        triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)\n      return false\n\n    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])\n  }\n  function ajaxSuccess(data, xhr, settings, deferred) {\n    var context = settings.context, status = 'success'\n    settings.success.call(context, data, status, xhr)\n    if (deferred) deferred.resolveWith(context, [data, status, xhr])\n    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])\n    ajaxComplete(status, xhr, settings)\n  }\n  // type: \"timeout\", \"error\", \"abort\", \"parsererror\"\n  function ajaxError(error, type, xhr, settings, deferred) {\n    var context = settings.context\n    settings.error.call(context, xhr, type, error)\n    if (deferred) deferred.rejectWith(context, [xhr, type, error])\n    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type])\n    ajaxComplete(type, xhr, settings)\n  }\n  // status: \"success\", \"notmodified\", \"error\", \"timeout\", \"abort\", \"parsererror\"\n  function ajaxComplete(status, xhr, settings) {\n    var context = settings.context\n    settings.complete.call(context, xhr, status)\n    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])\n    ajaxStop(settings)\n  }\n\n  function ajaxDataFilter(data, type, settings) {\n    if (settings.dataFilter == empty) return data\n    var context = settings.context\n    return settings.dataFilter.call(context, data, type)\n  }\n\n  // Empty function, used as default callback\n  function empty() {}\n\n  $.ajaxJSONP = function(options, deferred){\n    if (!('type' in options)) return $.ajax(options)\n\n    var _callbackName = options.jsonpCallback,\n      callbackName = ($.isFunction(_callbackName) ?\n        _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)),\n      script = document.createElement('script'),\n      originalCallback = window[callbackName],\n      responseData,\n      abort = function(errorType) {\n        $(script).triggerHandler('error', errorType || 'abort')\n      },\n      xhr = { abort: abort }, abortTimeout\n\n    if (deferred) deferred.promise(xhr)\n\n    $(script).on('load error', function(e, errorType){\n      clearTimeout(abortTimeout)\n      $(script).off().remove()\n\n      if (e.type == 'error' || !responseData) {\n        ajaxError(null, errorType || 'error', xhr, options, deferred)\n      } else {\n        ajaxSuccess(responseData[0], xhr, options, deferred)\n      }\n\n      window[callbackName] = originalCallback\n      if (responseData && $.isFunction(originalCallback))\n        originalCallback(responseData[0])\n\n      originalCallback = responseData = undefined\n    })\n\n    if (ajaxBeforeSend(xhr, options) === false) {\n      abort('abort')\n      return xhr\n    }\n\n    window[callbackName] = function(){\n      responseData = arguments\n    }\n\n    script.src = options.url.replace(/\\?(.+)=\\?/, '?$1=' + callbackName)\n    document.head.appendChild(script)\n\n    if (options.timeout > 0) abortTimeout = setTimeout(function(){\n      abort('timeout')\n    }, options.timeout)\n\n    return xhr\n  }\n\n  $.ajaxSettings = {\n    // Default type of request\n    type: 'GET',\n    // Callback that is executed before request\n    beforeSend: empty,\n    // Callback that is executed if the request succeeds\n    success: empty,\n    // Callback that is executed the the server drops error\n    error: empty,\n    // Callback that is executed on request complete (both: error and success)\n    complete: empty,\n    // The context for the callbacks\n    context: null,\n    // Whether to trigger \"global\" Ajax events\n    global: true,\n    // Transport\n    xhr: function () {\n      return new window.XMLHttpRequest()\n    },\n    // MIME types mapping\n    // IIS returns Javascript as \"application/x-javascript\"\n    accepts: {\n      script: 'text/javascript, application/javascript, application/x-javascript',\n      json:   jsonType,\n      xml:    'application/xml, text/xml',\n      html:   htmlType,\n      text:   'text/plain'\n    },\n    // Whether the request is to another domain\n    crossDomain: false,\n    // Default timeout\n    timeout: 0,\n    // Whether data should be serialized to string\n    processData: true,\n    // Whether the browser should be allowed to cache GET responses\n    cache: true,\n    //Used to handle the raw response data of XMLHttpRequest.\n    //This is a pre-filtering function to sanitize the response.\n    //The sanitized response should be returned\n    dataFilter: empty\n  }\n\n  function mimeToDataType(mime) {\n    if (mime) mime = mime.split(';', 2)[0]\n    return mime && ( mime == htmlType ? 'html' :\n      mime == jsonType ? 'json' :\n      scriptTypeRE.test(mime) ? 'script' :\n      xmlTypeRE.test(mime) && 'xml' ) || 'text'\n  }\n\n  function appendQuery(url, query) {\n    if (query == '') return url\n    return (url + '&' + query).replace(/[&?]{1,2}/, '?')\n  }\n\n  // serialize payload and append it to the URL for GET requests\n  function serializeData(options) {\n    if (options.processData && options.data && $.type(options.data) != \"string\")\n      options.data = $.param(options.data, options.traditional)\n    if (options.data && (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType))\n      options.url = appendQuery(options.url, options.data), options.data = undefined\n  }\n\n  $.ajax = function(options){\n    var settings = $.extend({}, options || {}),\n        deferred = $.Deferred && $.Deferred(),\n        urlAnchor, hashIndex\n    for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]\n\n    ajaxStart(settings)\n\n    if (!settings.crossDomain) {\n      urlAnchor = document.createElement('a')\n      urlAnchor.href = settings.url\n      // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049\n      urlAnchor.href = urlAnchor.href\n      settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host)\n    }\n\n    if (!settings.url) settings.url = window.location.toString()\n    if ((hashIndex = settings.url.indexOf('#')) > -1) settings.url = settings.url.slice(0, hashIndex)\n    serializeData(settings)\n\n    var dataType = settings.dataType, hasPlaceholder = /\\?.+=\\?/.test(settings.url)\n    if (hasPlaceholder) dataType = 'jsonp'\n\n    if (settings.cache === false || (\n         (!options || options.cache !== true) &&\n         ('script' == dataType || 'jsonp' == dataType)\n        ))\n      settings.url = appendQuery(settings.url, '_=' + Date.now())\n\n    if ('jsonp' == dataType) {\n      if (!hasPlaceholder)\n        settings.url = appendQuery(settings.url,\n          settings.jsonp ? (settings.jsonp + '=?') : settings.jsonp === false ? '' : 'callback=?')\n      return $.ajaxJSONP(settings, deferred)\n    }\n\n    var mime = settings.accepts[dataType],\n        headers = { },\n        setHeader = function(name, value) { headers[name.toLowerCase()] = [name, value] },\n        protocol = /^([\\w-]+:)\\/\\//.test(settings.url) ? RegExp.$1 : window.location.protocol,\n        xhr = settings.xhr(),\n        nativeSetHeader = xhr.setRequestHeader,\n        abortTimeout\n\n    if (deferred) deferred.promise(xhr)\n\n    if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest')\n    setHeader('Accept', mime || '*/*')\n    if (mime = settings.mimeType || mime) {\n      if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]\n      xhr.overrideMimeType && xhr.overrideMimeType(mime)\n    }\n    if (settings.contentType || (settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET'))\n      setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded')\n\n    if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name])\n    xhr.setRequestHeader = setHeader\n\n    xhr.onreadystatechange = function(){\n      if (xhr.readyState == 4) {\n        xhr.onreadystatechange = empty\n        clearTimeout(abortTimeout)\n        var result, error = false\n        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {\n          dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'))\n\n          if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob')\n            result = xhr.response\n          else {\n            result = xhr.responseText\n\n            try {\n              // http://perfectionkills.com/global-eval-what-are-the-options/\n              // sanitize response accordingly if data filter callback provided\n              result = ajaxDataFilter(result, dataType, settings)\n              if (dataType == 'script')    (1,eval)(result)\n              else if (dataType == 'xml')  result = xhr.responseXML\n              else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result)\n            } catch (e) { error = e }\n\n            if (error) return ajaxError(error, 'parsererror', xhr, settings, deferred)\n          }\n\n          ajaxSuccess(result, xhr, settings, deferred)\n        } else {\n          ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred)\n        }\n      }\n    }\n\n    if (ajaxBeforeSend(xhr, settings) === false) {\n      xhr.abort()\n      ajaxError(null, 'abort', xhr, settings, deferred)\n      return xhr\n    }\n\n    var async = 'async' in settings ? settings.async : true\n    xhr.open(settings.type, settings.url, async, settings.username, settings.password)\n\n    if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name]\n\n    for (name in headers) nativeSetHeader.apply(xhr, headers[name])\n\n    if (settings.timeout > 0) abortTimeout = setTimeout(function(){\n        xhr.onreadystatechange = empty\n        xhr.abort()\n        ajaxError(null, 'timeout', xhr, settings, deferred)\n      }, settings.timeout)\n\n    // avoid sending empty string (#319)\n    xhr.send(settings.data ? settings.data : null)\n    return xhr\n  }\n\n  // handle optional data/success arguments\n  function parseArguments(url, data, success, dataType) {\n    if ($.isFunction(data)) dataType = success, success = data, data = undefined\n    if (!$.isFunction(success)) dataType = success, success = undefined\n    return {\n      url: url\n    , data: data\n    , success: success\n    , dataType: dataType\n    }\n  }\n\n  $.get = function(/* url, data, success, dataType */){\n    return $.ajax(parseArguments.apply(null, arguments))\n  }\n\n  $.post = function(/* url, data, success, dataType */){\n    var options = parseArguments.apply(null, arguments)\n    options.type = 'POST'\n    return $.ajax(options)\n  }\n\n  $.getJSON = function(/* url, data, success */){\n    var options = parseArguments.apply(null, arguments)\n    options.dataType = 'json'\n    return $.ajax(options)\n  }\n\n  $.fn.load = function(url, data, success){\n    if (!this.length) return this\n    var self = this, parts = url.split(/\\s/), selector,\n        options = parseArguments(url, data, success),\n        callback = options.success\n    if (parts.length > 1) options.url = parts[0], selector = parts[1]\n    options.success = function(response){\n      self.html(selector ?\n        $('<div>').html(response.replace(rscript, \"\")).find(selector)\n        : response)\n      callback && callback.apply(self, arguments)\n    }\n    $.ajax(options)\n    return this\n  }\n\n  var escape = encodeURIComponent\n\n  function serialize(params, obj, traditional, scope){\n    var type, array = $.isArray(obj), hash = $.isPlainObject(obj)\n    $.each(obj, function(key, value) {\n      type = $.type(value)\n      if (scope) key = traditional ? scope :\n        scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']'\n      // handle data in serializeArray() format\n      if (!scope && array) params.add(value.name, value.value)\n      // recurse into nested objects\n      else if (type == \"array\" || (!traditional && type == \"object\"))\n        serialize(params, value, traditional, key)\n      else params.add(key, value)\n    })\n  }\n\n  $.param = function(obj, traditional){\n    var params = []\n    params.add = function(key, value) {\n      if ($.isFunction(value)) value = value()\n      if (value == null) value = \"\"\n      this.push(escape(key) + '=' + escape(value))\n    }\n    serialize(params, obj, traditional)\n    return params.join('&').replace(/%20/g, '+')\n  }\n})(Zepto)\n\n;(function($){\n  $.fn.serializeArray = function() {\n    var name, type, result = [],\n      add = function(value) {\n        if (value.forEach) return value.forEach(add)\n        result.push({ name: name, value: value })\n      }\n    if (this[0]) $.each(this[0].elements, function(_, field){\n      type = field.type, name = field.name\n      if (name && field.nodeName.toLowerCase() != 'fieldset' &&\n        !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&\n        ((type != 'radio' && type != 'checkbox') || field.checked))\n          add($(field).val())\n    })\n    return result\n  }\n\n  $.fn.serialize = function(){\n    var result = []\n    this.serializeArray().forEach(function(elm){\n      result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))\n    })\n    return result.join('&')\n  }\n\n  $.fn.submit = function(callback) {\n    if (0 in arguments) this.bind('submit', callback)\n    else if (this.length) {\n      var event = $.Event('submit')\n      this.eq(0).trigger(event)\n      if (!event.isDefaultPrevented()) this.get(0).submit()\n    }\n    return this\n  }\n\n})(Zepto)\n\n;(function(){\n  // getComputedStyle shouldn't freak out when called\n  // without a valid element as argument\n  try {\n    getComputedStyle(undefined)\n  } catch(e) {\n    var nativeGetComputedStyle = getComputedStyle\n    window.getComputedStyle = function(element, pseudoElement){\n      try {\n        return nativeGetComputedStyle(element, pseudoElement)\n      } catch(e) {\n        return null\n      }\n    }\n  }\n})()\n  return Zepto\n}))\n","/*! Hammer.JS - v2.0.8 - 2016-04-23\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n;(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.8';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (typeof define === 'function' && define.amd) {\n    define(function() {\n        return Hammer;\n    });\n} else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n} else {\n    window[exportName] = Hammer;\n}\n\n})(window, document, 'Hammer');\n",";(function(factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(['Zepto', 'hammerjs'], factory);\n    } else if (typeof exports === 'object') {\n        factory(require('Zepto'), require('hammerjs'));\n    } else {\n        factory($, Hammer);\n    }\n}(function($, Hammer) {\n    function hammerify(el, options) {\n        var $el = $(el);\n        if(!$el.data(\"hammer\")) {\n            $el.data(\"hammer\", new Hammer($el[0], options));\n        }\n    }\n\n    $.fn.hammer = function(options) {\n        return this.each(function() {\n            hammerify(this, options);\n        });\n    };\n\n    // extend the emit method to also trigger jQuery events\n    Hammer.Manager.prototype.emit = (function(originalEmit) {\n        return function(type, data) {\n            originalEmit.call(this, type, data);\n            $(this.element).trigger({\n                type: type,\n                gesture: data\n            });\n        };\n    })(Hammer.Manager.prototype.emit);\n}));\n"]}